#define MOTOR_A_SPD 10  // 모터A의 속도를 결정하는 PWM 핀
#define MOTOR_A_DIR 12   // 모터A의 방향을 결정하는 디지털 핀 (원문에는 MOTOR_A_DIR_PIN으로 되어 있지만, 일반적으로 DIR로 줄여서 사용하며, motor_drive() 함수에[...]
#define MOTOR_B_SPD 11  // 모터B의 속도를 결정하는 PWM 핀
#define MOTOR_B_DIR 13  // 모터B의 방향을 결정하는 디지털 핀 (원문에는 MOTOR_B_DIR_PIN으로 되어 있지만, motor_drive() 함수에 맞춰 수정했습니다.)
#define A_BAL 1         // 모터A의 균형 계수 (속도 보정값)
#define B_BAL 1         // 모터B의 균형 계수 (속도 보정값)
#define M_SPEED 100     // 모터 초기 기본 속도 (PWM 값, 0~255)

// "홀드(hold)" 동작을 위한 타임아웃 (ms).
// 원격 앱/컨트롤러가 버튼을 누르고 있는 동안 계속해서 문자(예: 'F')를 전송하면,
// 이 타임아웃이 갱신되어 모터가 계속 동작합니다.
// 반대로 입력이 끊기면 이 시간 이후 자동으로 정지합니다.
const unsigned long HOLD_TIMEOUT = 300; // 필요하면 조정하세요 (밀리초)

unsigned long lastCmdMillis = 0; // 마지막으로 명령을 받은 시각 (millis)
unsigned char lastCmd = 0;       // 마지막 명령 저장

// 모터의 회전 방향 및 속도 전역 변수
unsigned char m_a_spd = 0, m_b_spd = 0; // PWM 속도 값 (0~255)
boolean m_a_dir = 0, m_b_dir = 0; // 방향 플래그 (0 또는 1)

void setup() {
  Serial.begin(9600); // 시리얼 통신 초기화 (보율 9600)

  pinMode(MOTOR_A_DIR, OUTPUT); // 모터A 방향 핀 출력으로 설정
  pinMode(MOTOR_B_DIR, OUTPUT); // 모터B 방향 핀 출력으로 설정
  // PWM 핀은 analogWrite에서 자동으로 설정되므로 pinMode 불필요

  Serial.println("Hello! (hold mode)"); // 모터 작동 확인용 문자 출력
}

void loop() {
  unsigned char bt_cmd = 0; // 명령어 저장을 위한 변수

  if (Serial.available()) { // 시리얼 데이터가 입력되었을 때
    bt_cmd = (unsigned char)Serial.read(); // 변수에 입력된 데이터 저장
    lastCmd = bt_cmd;
    lastCmdMillis = millis(); // 명령을 받은 시각 갱신

    rc_ctrl_val(bt_cmd);       // 받은 명령으로 모터 상태 설정
  } else {
    // 일정 시간 동안 아무 입력도 없으면 "홀드" 해제 — 모터 정지
    if (millis() - lastCmdMillis > HOLD_TIMEOUT) {
      // 이미 정지 상태가 아니면 정지로 설정
      if (m_a_spd != 0 || m_b_spd != 0) {
        stopMotors();
      }
    }
  }

  motor_drive();    // 현재 설정된 방향/속도를 실제 핀에 출력
}

// 입력된 명령어(cmd)에 따라 모터의 방향과 속도를 설정하는 함수
void rc_ctrl_val(unsigned char cmd) {
  if (cmd == 'F') { // 'F'가 입력되었을 때, 전진
    m_a_dir = 1; // 정방향
    m_b_dir = 1; // 정방향
    m_a_spd = M_SPEED * A_BAL; // 속도 + 보정값
    m_b_spd = M_SPEED * B_BAL;
  } else if (cmd == 'L') { // 'L'가 입력되었을 때, 좌회전 (오른쪽 모터만 구동)
    m_a_dir = 1; // 정방향
    m_b_dir = 1; // 정방향
    m_a_spd = 0; // 모터A 정지
    m_b_spd = M_SPEED * B_BAL; // 모터B만 움직임
  } else if (cmd == 'R') { // 'R'가 입력되었을 때, 우회전 (왼쪽 모터만 구동)
    m_a_dir = 1; // 정방향
    m_b_dir = 1; // 정방향
    m_a_spd = M_SPEED * A_BAL; // 모터A만 움직임
    m_b_spd = 0; // 모터B 정지
  } else if (cmd == 'C') { // 'C'가 입력되었을 때, 제자리 좌회전 (A 정, B 역)
    m_a_dir = 1; // 정방향
    m_b_dir = 0; // 역방향
    m_a_spd = M_SPEED * A_BAL;
    m_b_spd = M_SPEED * B_BAL;
  } else if (cmd == 'X') { // 'X'가 입력되었을 때, 제자리 우회전 (A 역, B 정)
    m_a_dir = 0; // 역방향
    m_b_dir = 1; // 정방향
    m_a_spd = M_SPEED * A_BAL;
    m_b_spd = M_SPEED * B_BAL;
  } else if (cmd == 'B') { // 'B'가 입력되었을 때, 후진
    m_a_dir = 0; // 역방향
    m_b_dir = 0; // 역방향
    m_a_spd = M_SPEED * A_BAL;
    m_b_spd = M_SPEED * B_BAL;
  } else if (cmd == 'P') { // 'P'가 입력되었을 때, 정지
    m_a_dir = 1; // (방향은 유지하거나 정방향으로 설정)
    m_b_dir = 1;
    m_a_spd = 0; // 속도 정지
    m_b_spd = 0; // 속도 정지
  }
}

// 설정된 변수(방향, 속도)를 모터 드라이버 핀에 출력하는 함수
void motor_drive() {
  digitalWrite(MOTOR_A_DIR, m_a_dir); // 모터A의 방향을 디지털 출력
  digitalWrite(MOTOR_B_DIR, m_b_dir); // 모터B의 방향을 디지털 출력
  analogWrite(MOTOR_A_SPD, m_a_spd); // 모터A의 속도(PWM) 출력
  analogWrite(MOTOR_B_SPD, m_b_spd); // 모터B의 속도(PWM) 출력
}

// 즉시 모터를 정지시키는 유틸 함수
void stopMotors() {
  m_a_spd = 0;
  m_b_spd = 0;
  // 방향은 어차피 속도가 0이면 무의미하므로 건드리지 않음
}
